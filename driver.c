/*
BATCH NO. 27
Mayank Agarwal (2014A7PS111P)
Karan Deep Batra(2014A7PS160P)
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "lexerDef.h"
#include "lexer.h"
#include "grammar.h"
#include "first.h"
#include "follow.h"
#include "parser.h"
#include "parserDef.h"
#include "mainsymboltable.h"
#include "makeAST.h"
#include "typeExtractor.h"
#include "semantics.h"
#include "codegen.h"

void printCleanFile()
{
	FILE* fp = fopen("cleanFile.txt", "r");
	fseek(fp,0,SEEK_END);
	size_t inputsize = ftell(fp);
	rewind(fp);

	for(int i=0; i<inputsize; i++)
	{
		char ch = fgetc(fp);
		printf("%c", ch);
	}

	return;
}

void printTokens()
{
	if(tokenlist == NULL)
		return;

	tokeninfo* temp = tokenlist;

	while(strcmp(temp->tokenname, "$") != 0)
	{
		if(strcmp(temp->tokenname, "ERROR_1") == 0)
		{
			printf("ERROR_1: Identifier at line %d is longer than the prescribed length\n", temp->linenumber);
		}
		else if(strcmp(temp->tokenname, "ERROR_2") == 0)
		{
			printf("ERROR_2: Unknown Symbol %s at line %d\n", temp->lexeme, temp->linenumber);
		}
		else if(strcmp(temp->tokenname, "ERROR_3") == 0)
		{
			printf("ERROR_3: Unknown pattern %s at line %d\n", temp->lexeme, temp->linenumber);
		}
		else{
			printf("%s %s %d\n", temp->tokenname, temp->lexeme, temp->linenumber);
		}
		temp = temp->next;
	}
	return;
}

void printErrorTokens()
{
	if(tokenlist == NULL)
		return;

	tokeninfo* temp = tokenlist;

	while(strcmp(temp->tokenname, "$") != 0)
	{
		if(strcmp(temp->tokenname, "ERROR_1") == 0)
		{
			printf("ERROR_1: Identifier at line %d is longer than the prescribed length\n", temp->linenumber);
		}
		else if(strcmp(temp->tokenname, "ERROR_2") == 0)
		{
			printf("ERROR_2: Unknown Symbol %s at line %d\n", temp->lexeme, temp->linenumber);
		}
		else if(strcmp(temp->tokenname, "ERROR_3") == 0)
		{
			printf("ERROR_3: Unknown pattern %s at line %d\n", temp->lexeme, temp->linenumber);
		}
		temp = temp->next;
	}
	return;
}

int main(int argc, char* argv[])
{
	printf("Level 4: Symbol Table/ AST/ Type Checking/ Semantic Rules/ Code Generation modules work.\n");

	if(argc < 3)
	{
		printf("USAGE: ./compiler testcase.txt code.asm");
		return 0;
	}
	FILE* fp = fopen(argv[1], "rb");
	removeComments(fp);
	fclose(fp);
	
	fp = fopen(argv[1], "rb");
	tokenlist = getAllTokens(fp);
	fclose(fp);

	hashtable* table = makehashtable();
	populateGrammar(table);

	// printhashtable(table);
	// printGrammar(table);
	// printTopDownGrammar(table);

	populateFirstSets(table);
	// printFirstSets(table);

	populateFollowSets(table);
	// printFollowSets(table);

	makeParseTable(table);
	// printParseTable(table);

	// int syntaxcorrect = parseGrammar(table, tokenlist);
	// printParseTree(root, "ROOT");

	
	int control;
	printf("------------------------------------------------------------\n");
	printf("Press the appropriate option\n");
	printf("1 : For printing the token list generated by the lexer.\n");
	printf("2 : For parsing to verify the syntactic correctness of the input source code and to produce parse tree.\n");
	printf("3 : For printing the inorder traversal of the Abstract Syntax Tree in appropriate format\n");
	printf("4 : For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree.\n");
	printf("5 : For printing the Symbol Table.\n");
	printf("6 : For compiler to verify the syntactic and semantic correctness of the input source code.\n");
	printf("7 : For producing assembly code (only when there is no syntactic, semantic or type mismatch errors).\n");

	scanf("%d",&control);


	if(control == 1)
	{
		printTokens();
	}
	if(control == 2)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 0);
		if(syntaxcorrect)
			printParseTree(root, "ROOT");
		else
			printf("ERROR in making Parse Tree because parsing is not correct.\n");
	}
	if(control == 3)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 0);
		if(syntaxcorrect)
		{
			makeAST(root, "ROOT");
			printAST(root, "ROOT");
		}
		else
			printf("ERROR in making Abstract Syntax Tree because parsing is not correct.\n");
	}
	if(control == 4)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 0);
		if(syntaxcorrect)
		{
			int nodesPT = 0, memoryPT = 0;
			parseTreeMemory(root, &nodesPT, &memoryPT);
			printf("Parse Tree\tNumber of Nodes = %d\tAllocated Memory = %d\tBytes\n", nodesPT, memoryPT);
			int nodesAST = 0, memoryAST = 0;
			makeAST(root, "ROOT");
			astMemory(root, &nodesAST, &memoryAST);
			printf("AST\t\tNumber of Nodes = %d\tAllocated Memory = %d\tBytes\n", nodesAST, memoryAST);
			printf("Compression Percentage = %f\n", ((memoryPT-(float)memoryAST)/memoryPT)*100);
		}
		else
			printf("ERROR, parsing is not correct.\n");			
	}
	if(control == 5)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 0);
		if(syntaxcorrect)
		{
			makeAST(root, "ROOT");
			mainsymboltable* globaltable = makemainsymboltable();
			populatemainsymboltable(root, NULL, globaltable, 0);
			printmainsymboltable(globaltable);
		}
	}
	if(control == 6)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 0);
		if(syntaxcorrect == 0)
		{	
			printf("Syntax Errors :\n");
			printErrorTokens();
			parseGrammar(table, tokenlist, 1);
		}
		else
		{
			makeAST(root, "ROOT");
			mainsymboltable* globaltable = makemainsymboltable();
			populatemainsymboltable(root, NULL, globaltable, 1);
			traverseAST_fortypechecking(root);
			checkSemantics(root, globaltable);
			if(semanticCorrect == 0)
				printf("Code Compiled Successfully.....\n");
		}
	}
	if(control == 7)
	{
		int syntaxcorrect = parseGrammar(table, tokenlist, 1);
		if(syntaxcorrect)
		{	
			FILE* asmFile = fopen(argv[2], "w+");
			makeAST(root, "ROOT");
			mainsymboltable* globaltable = makemainsymboltable();
			populatemainsymboltable(root, NULL, globaltable, 0);
			generate_code(asmFile, globaltable, root);
			fclose(asmFile);
		}
		else
			printf("ERROR, Syntax errors exist in the code.\n");
	}
	return 0;
}